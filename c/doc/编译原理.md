# 编译原理

首先，我们将人类编辑的代码称为源码，源码存储的文件成为源文件；将计算机执行的字节序列成为程序，程序存储的文件称为
可执行文件。在C语言中，源码需要经过预编译器、编译器、汇编器、链接器四个过程后才能生成程序。源码经过预编译器将预
编译命令进行处理，将经过预编译的源码称为预编译源码，保存在预编译源文件中；之后通过编译器生成汇编源码，将汇编源码
存储的文件成为汇编源文件；汇编源码通过汇编器生成字节序列。

* 预编译提供文件包含、宏定义、条件编译三种预处理指令，文件包含即会将所包含的文件拷贝在此处，宏定义是在使用宏的地
方使用宏值替换（不会进行任何处理），条件编译是根据判断条件选择是否编译该段源码。域编译源文件不会生成，不过对于gcc
可以使用-E参数来显示域编译源文件。

[//]: # (@issue: 如何生成域编译文件好像不知道。现在只能使用管道的方式生成域编译文件。)

* 编译器是实现将C语言编译为汇编语言的程序，再次过程中需要经过词法分析、语法分析、中间代码、代码优化、目标代码五个
过程，汇编一般是将高级语言转化为汇编语言的过程。生成的汇编源码保存在汇编源文件中（一般以`*.s`作为标识），对于gcc
可以使用-S参数来生成汇编源文件。

[//]: # (@idea: 该汇编文件是否与OS或者硬件平台相关。)

* 汇编器是将汇编源码生成字节序列的程序，好像在资料中发现，经常将该字节序列称为目标程序，保存的文件成为目标文件；在
C语言中，可以汇编器生成的目标文件打包成库文件（有动态库与静态库两种），一般以`*.o`标识该文件。对于gcc可以使用-c参
数来生成目标文件。

[//]: # (@note： 作为扩展，可以了解一下反汇编器。objdump )

* 链接器是根据汇编器生成的目标程序以及已有的库文件链接生成可执行程序的过程。对于源文件的部分修改需要重新编译与汇编，
从而造成计算机资源的浪费，连接器就是可以解决这一问题，将程序分成各个独立模块，在维护过程中，只编译与汇编修改的部分
最后使用链接器链接各独立模块即可。

[//]: # (@issue: 链接器的具体工作过程是什么。)

## 编译工具简述

现有的编译工具有GCC，Clang等。

* [GCC](https://gcc.gnu.org/)是属于GNU项目，原为GNU开发的编译工具，现已支持跨平台，MGwin64是Windows支持的
GCC版本。

* [Clang](https://clang.llvm.org/)是基于LLVM的C编译工具。

在开发项目愈发庞大的情境下，单纯的使用编译器似乎不满足开发需求，所以有了make与cmake。

* [Make]()是一个批处理工具。使用通过makefile中指定的规则来执行。

* [CMake](https://cmake.org/)可以生成平台对应编译规则文件（为make生成makefile文件），这一功能是根据
CMakeLists.txt来生成。

## 打包库文件

### 静态库文件

静态库文件，在linux中以`*.a`标识，在Windows中以`*.lib`标识。


### 动态库文件

动态库文件，在Linux中以`*.so`标识，在Windows中以`*.dll`标识。



## 编译工具

* gcc
* nm
* objdump
* addr2line

