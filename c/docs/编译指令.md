编译指令是存在于源码中的特定指令，该指令会在与编译之前由预处理器来进行转化、替换以及设定编译参数。

条件编译是常用的编译指令，通常在头文件中来避免被多次引入。

```c
#ifndef __INCLUDE_H__
#define __INCLUDE_H__

// @todo:

# endif // __INCLUDE_H__
```

```c
#idef DEBUG

// @todo：

#endif
```

文件包含是用于包含文件的编译指令，通常用于包含头文件

```c
#include <include.h>
```

宏定义是设置宏定义的编译指令，在预处理阶段会被指定的对象替换，

```c
#define DEBUG
#define VERSION 0.0.0.1
#undef DEBUG
```


* 用作 常数及简单的计算 对其中变量只做替换，不做计算
* 可带参数实现函数功能
* #undef 取消已定义的宏定义 --- 将宏定义限制在一个代码块内


* `#`的用法：#是将参数转化为字符串，例如在输出参数的变量时，可以这样使用：

  ```c
  #define sum(a,b) printf("%s+%s=%d",#a,#b,a+b)

  int main() {
    int suma=1, sumb=2;
    sum(sunma, sunmb);
  }
  ```

  > Note: 将会输出`suma+sumb=3`的结果。除了这样使用还有字符串中转化为指定的标识符。例如`printf("number "#x"'s value is %d", x)`。



* `##`的用法：可以前后两个字符进行粘合

  ```c
  #define print(object) object ## print  // 改结果会使用`<object>print`来替换宏。
  #define INT(n) int ## n
  INT(8)
  ```

  > Note: #或者##在每一次宏定义时只能出现一次。
  
### 条件编译

* ifdef - endif

  ```C
  #ifdef <标识符>
  <程序段>;
  #endif  
  ```

* ifdef - else - endif 条件编译

  ```C
  #ifdef <标识符>
  <程序段1>;
  #else
  <程序段2>;
  #endif        //如果标识符已被 #define 命令定义过则对程序段 1 进行编译;否则对程序段 2 进行编译。
  ```

* ifndef - else - endif 条件编译

  ```C
  #ifndef <标识符>
  <程序段1>;
  #else
  <程序段2>;
  #endif        //如果标识符未被#define 命令定义过则对程 序段 1 进行编译,否则对程序段 2 进行编译。这与第一种形式的功能正好相反。
  ```

* if - else - endif 条件编译

  ```C
  #if <常量表达式>
  <程序段1>;
  #else
  <程序段2>;
  #endif      //常量表达式的值为真(非 0),则对程序段 1 进行编译,否则对程序段 2 进行编译。
  ```

### 编译停止

> 强制停止编译:

  ```C
  #error <message>    //强制停止编译并输出信息;
  ```

> 修改特殊变量的值: 主要用于调试与特殊应用

  ```C
  #line <行号值> <当前编译文件名>   //修改 __LINE__ 与 __FILE__ 值 (__LINE__ 与　__FILE＿　是预编译程序中预定义的标识符)
  ```

* 文件包含
  
  * #include <fileName>

### 编译参数

* 编译指示指令

  * #pragram: 设定编译器的状态,指示编译器完成一些特定的动作

    | 参数     | 说明 |
    | :------- | ---- |
    | message  |      |
    | code_seg |      |
    | once     |      |
    | hdrstop  |      |
    | resource |      |
    | warning  |      |
    | comment  |      |

* 预定义的宏名:
  * \_LINE\_    行号
  * \_FILE\_     名称
  * \_DATA\_    日期
  * \_TIME\_     时间
  * \_STDC\_    是否执行ANSI C标准

## 编译属性

* `__attribute__`



* `volatile`提示编译器该修饰词之后的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量，都是直接从
变量地址中读取数据。如果没有volatile,则编译器可能会优化读取与存储：暂时使用寄存器中的值，而不是实际地址中的值。一
般对等待其他程序改变的变量均使用该限定词，以保证数据的实时性。




