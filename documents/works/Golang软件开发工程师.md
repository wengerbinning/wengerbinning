# 自我介绍

## Golang

### runtime

> 尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。

### GPM模型(go的调度)

> 内核态线程（n:1）
>
> 用户态线程（1:1）
>
> 两级线程（n:n）
>
> G: goroutine
>
> P: processor 表示处理器，有了它才能建立G、M的联系,Proccessor负责Machine与Goroutine的连接，它能提供线程需要的上下文环境，也能分配G到它应该去的线程上执行,同样的，处理器的数量也是默认按照GOMAXPROCS来设置的
>
> M: machine 表示操作系统的线程,最多会有GOMAXPROCS个活跃线程能够正常运行
>
> P的角色相当于G到M的调度也就是用户态线程到操作系统线程的调度，有一个全局队列以及每个P都有一个本地队列里面存放着待运行的G,P必须绑定一个M才能运行，当P的本地队列为空时，会优先去其他P的本地队列偷取一半的G

### 协程泄露

> 

### go的struct可不可以比较

> 本质上比较内部属性，内部属性可以比较就比较

### go defer

> 执行顺序，defer后的语句再return之前执行，多个defer由后往前执行，defer后的函数参数顺序执行。

### select

> select就是用来监听和channel有关的IO操作，当 IO 操作发生时，触发相应的动作。

### context

> context主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。另外在使用context时有两点值得注意：上游任务仅仅使用context通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说context的取消操作是无侵入的；context是线程安全的，因为context本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。
>
> withCancel
>
> withDeadline
>
> withTImeout
>
> withValue

### golang 切片容器扩容机制

> 翻倍

### golang GC

> 三色标记法
>
> 1. 初始时所有对象均为白色
> 2. 从根出发，扫描所有对象，将他们引用的对象标记为灰色
> 3. 分析灰色对象是否引用了其他对象，如果没有将该灰色对象标记为黑色，如果有则将他引用的对象标记为灰色，将他自己标记为黑色
> 4. 重复步骤3直到没有灰色对象。此时白色对象即为垃圾
>
> https://juejin.im/post/6844903917650722829

### client实现长链接

> Connection: keep-alive

### map如何实现顺序读取

> 直接读取map是无序的，可以先将map中的key存在一个slice中，然后对slice进行排序，按slice中的顺序进行读取map中的数据；简单点说：使用slice

### goroutine通信

> channel

### 反射

> 反射是指在程序运行期对程序本身进行访问和修改的能力。

### go怎么管理协程

> context,
>
> sync.WaitGroup
>
> channel

### CPU中的线程和程序中的线程的区别

> CPU的指的是CPU可以同时运行的线程数量，是可以同时执行的代码路径数量，程序中的表示你实际用到的，如果程序的线程数多于CPU的线程数，那敢并不是真正的并行，各线程会占用在一个很短的时间片里依次得到执行，用户看似是同时运行的

### 闭包

> 闭包指的是一个函数和与其相关的引用环境组合而成的实体。
>
> 简单的说就是函数使用了外部的变量，这个变量在函数生命周期中一直存在
>
> https://www.liwenzhou.com/posts/Go/09_function/#autoid-2-3-2

### MAP的实现



### sync.Map

> - 通过 read 和 dirty 两个字段将读写分离，读的数据存在只读字段 read 上，将最新写入的数据则存在 dirty 字段上
> - 读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty
> - 读取 read 并不需要加锁，而读或写 dirty 都需要加锁
> - 另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上
> - 对于删除数据则直接通过标记来延迟删除

## 微服务

### 什么是微服务

> 微服务是一种开发软件的架构和组织方法，其中软件由通过明确定义的 API 进行通信的小型独立服务组成。这些服务由各个小型独立团队负责。微服务架构使应用程序更易于扩展和更快地开发，从而加速创新并缩短新功能的上市时间。



## HTTP

### session和cookie的区别

> session储存在服务器，cookie储存在浏览器

### http1.x 与 http2.0的区别

> 1. 新的二进制格式（Binary Format）
>
> 2. 共享连接
>
>    ...

### https 是如何加密的

> 用不对称加密（公钥加密私钥解，私钥加密公钥解）加密对称加密密钥
>
> 问题一：如何保证中间人攻击，既如何保证浏览器收到的密钥来自目标服务器，而不是中间人？
>
> 答：**CA机构**颁发数字证书（内含持有者和持有者公钥）
>
> 问题二：如何保证浏览器收到的证书没有被篡改？
>
> 答：数字签名

### Keep-Alive

> 客户端和服务端在建立连接并完成request后并不会立即断开TCP连接，而是在下次request来临时复用这次TCP连接。但是这里也必须要有TCP连接的timeout时间限制。不然会造成服务端端口被长期占用释放不了。
>
> 对于不适用keepalive的request来说，不管是客户端还是服务端都是通过TCP的链接的断开知道request的结束（TCP 挥手时会check 数据包的 seq， 保证数据完整性）。
>  支持keepalive后，如何知道request结束了呢？
>  在Http1.1的版本里， 解决方案是request 和reponse里使用**contentLength**来帮助确认是否收到全部数据。

### 常见状态码

> **2xx （3种）**
>
> **200 OK：**表示从客户端发送给服务器的请求被正常处理并返回；
>
> **204 No Content：**表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；
>
> **206 Patial Content：**表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
>
> **3xx （5种）**
>
> **301 Moved Permanently：**永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
>
> **302 Found：**临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
>
> ​    301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
>
> **303 See Other：**表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；
>
>    302与303的区别：后者明确表示客户端应当采用GET方式获取资源
>
> **304 Not Modified：**表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；
>
> **307 Temporary Redirect：**临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；
>
> **4xx （4种）**
>
> **400 Bad Request：**表示请求报文中存在语法错误；
>
> **401 Unauthorized：**未经许可，需要通过HTTP认证；
>
> **403 Forbidden：**服务器拒绝该次访问（访问权限出现问题）
>
> **404 Not Found：**表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；
>
> **5xx （2种）**
>
> **500 Inter Server Error：**表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；
>
> **503 Server Unavailable：**表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；

### 反向代理

> Nginx，
>
> 位于用户和服务器之间

## RPC

### 什么是RPC

> 远程过程调用,该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。

### 什么时gRPC

> 是谷歌开源的高性能RPC框架

## TCP

### 什么是Socket

> 两个网络应用进行通信的两个端点

### 三次握手和四次挥手

> ![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
>
> ![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 滑动窗口

> 目的：流量控制
>
> 场景：发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制， 协调好通信双方的工作节奏。
>
> ![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103123177-958324725.jpg)

### 拥塞控制

> 1.慢开始
> 2.拥塞控制
> 3.快重传
> 4.快恢复

### 流量控制

> 滑动窗口

### TCP与UDP的区别，及优缺点，适合场景

> TCP面向链接提供可靠传输，UDP是无连接的尽最大努力交付。
>
> UDP具有较好的实时性适用于高速传输和实时性较高的通信。

## Mysql

### 存储过程

> 

### 关系数据库与非关系数据库的区别

> 关系型：以表格形式存储，
>
> 非关系型：以键值对形式存储

### 事务四属性

> ACID, 
>
> - A, atomacity 原子性
>
>   事务必须是原子工作单元；
>
> - C, consistency 一致性
>
>   事务将数据库从一种一致状态转变为下一种一致状态。
>
> - I, isolation 隔离性
>
>   由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。
>
> - D, durability 持久性
>
>   事务完成之后，它对于系统的影响是永久性的。

### 事务隔离等级

> - 读未提交（read uncommitted），A事务可以读取到B事务中未提交的数据，出现 **脏读**。
> - 读已提交（read committed），A事务可以读取到B事务已提交的数据，但A事务读取两次，刚好对应B事务未提交和已提交，则两次的读取不一致，出现 **不可重复读**。
> - 可重复读（repeatable read）,mysql 的默认隔离级别，在同一个事务里，select到的数据都是该事务开始时候的状态，如果此时B事务已经提交，但A事务仍旧会读旧的数据，出现**幻读**。
> - 序列化，最高隔离级别，所有的事务强制串行。

### 三范式

> 1. 列不可再分
> 2. 属性完全依赖于主键
> 3. 属性不依赖于其它非主属性   属性直接依赖于主键

### innodb和myisam区别

> innodb支持事务，适用于需要执行大量insert和update操作；myisam提供高速存储和检索，适用于大量select操作。
>
> 全文检索

### 索引

> https://www.runoob.com/mysql/mysql-index.html
>
> 1. 数据库有哪些索引？（**字节**）
>
>    - 唯一索引
>    - 主键索引
>    - 普通索引
>    - 全文索引
> 2. 索引的实现方式？**（恒生）**
>
>    - b+树
>    - hash索引
>    - bitmap

### Mysql联表方式

> left join
>
> right join
>
> join

### B树和B+树的区别

> B

## Redis

### Redis过期的原理

> 。。。

### 基本数据类型及底层数据结构

> 1. string
>
>    > 简单动态字符串(SDS)，内涵一个char数组，len属性表示数组已用空间，free属性表示剩余空间。
>
> 2. set
>
>    > 
>
> 3. zset
>
>    > 
>
> 4. list
>
>    > 双向链表
>
> 5. hash
>
>    > hash表数组，hash表大小，hash表掩码，哈希表已有节点数量

### Redis持久化机制

> 单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。
>
> RDB
>
> RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。
>
> AOF
>
> 将每条命令都存在日志中

### 单线程的redis为什么这么快

> 1. 纯内存操作
> 2. 单线程避免了频繁的上下文切换
> 3. 采用了非阻塞I/O多路复用

### redis的主从复制问题

> 什么是主从复制：防止硬盘损坏而照成数据丢失，需要将主服务器中的数据备份到几个从服务器中。
>
> 要求主从数据实时同步，
>
> 从redis需要修改配置文件中的`slaveof `
>
> 过程
>
> slave 服务启动，slave 会建立和 master 的连接，发送 sync 命令。
>
> master 启动一个后台进程将数据库快照保存到 RDB 文件中
>
> 注意：此时如果生成 RDB 文件过程中存在写数据操作会导致 RDB 文件和当前主 redis 数据不一致，所以此时 master 主进程会开始收集写命令并缓存起来。
>
> master 就发送 RDB 文件给 slave
>
> slave 将文件保存到磁盘上，然后加载到内存恢复
>
> master 把缓存的命令转发给 slave
>
> 注意：后续 master 收到的写命令都会通过开始建立的连接发送给 slave。
>
> 当 master 和 slave 的连接断开时 slave 可以自动重新建立连接。如果 master 同时收到多个 slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有 slave。

### 消息队列



## 数据结构

### 哈夫曼树

> 哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近

### 左旋右旋

> https://blog.csdn.net/tuhuolong/article/details/6844850

### 栈

> 只能一端操作，后进先出，类似弹夹
>
> 使用场景
>
> 

## 算法

### 经典排序

> | 算法名称 | 时间复杂度 | 参考                                             |
> | -------- | ---------- | ------------------------------------------------ |
> | 快速排序 | O(nlogn)   | https://www.cnblogs.com/kainhuck/p/12961997.html |
> | 归并排序 | O(nlogn)   | https://www.cnblogs.com/kainhuck/p/12965748.html |
> | 堆排序   | O(nlogn)   | https://www.cnblogs.com/kainhuck/p/12972395.html |
>
> 

### 动态规划

> - **基本思想：**问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题**有较多的重复出现**，则可以**自底向上**从最终子问题向原问题逐步求解。

### 最短路径

> Dijkstra(迪杰斯特拉)算法
>
> > 1. 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。
> > 2. 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。
> > 3. 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。
> >
> > https://blog.csdn.net/qq_37796444/article/details/80663810
>
> Floyd(弗洛伊德)算法
>
> > 思想：动态规划，找一个中转点，判断是否时最短的
> >
> > https://blog.csdn.net/shezjoe/article/details/80670188

## 操作系统

### 进程和线程,协程

> - 进程
>
> 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
>
> - 线程
>
> 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
>
> - 协程
>
> 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### cache

> 

### 死锁

> 死锁产生的四个必要条件:
>
> 1. 互斥条件：一个资源每次只能被一个进程使用
> 2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
> 3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
> 4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
>
> a. 预防死锁
>
> 可以把资源一次性分配：（破坏请求和保持条件）
>
> 然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）
>
> 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
>
> b. 避免死锁
>
> 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。
>
> c. 检测死锁
>
> 首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表.
>
> d. 解除死锁
>
> 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有.
>
> e. 剥夺资源
>
> 从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.
>
> f. 撤消进程
>
> 可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先级、运行代价、进程的重要性和价值等。

### 孤儿进程和僵尸进程，守护进程

> 孤儿进程（被父亲遗弃的进程）
>
> 如果父进程先退出,子进程还没退出那么子进程将被 托孤给init进程,这时子进程的父进程就是init进程(1号进程)
>
> 僵尸进程（作为子进程结束后应当被释放但是未被释放进入僵死状态）
>
> 如果一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束.
>
> 守护进程
>
> 后台进程，不与任何终端关联

### 多路复用

> 单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。

### 用户态和内核态

> 用户态切换到内核态主要有三种方式
>
> - 系统调用
> - 中断
> - 异常
>
> 

## GIT

### merge 和 rebase的区别

> https://www.jianshu.com/p/f23f72251abc



## WebSocket

### 有了http为啥还要ws

> HTTP缺点：请求只能由客户端发起，服务端有变化不能主动向客户端推送
>
> 解决思路：轮询，webook，wesocket

### 什么是websocket

> websocket是一种建立在单个TCP上的全双工通信

## Docker

### 镜像和容器之间的关系

> 

## 后端

