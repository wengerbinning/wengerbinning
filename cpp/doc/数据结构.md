# C++数据结构

C++的数据结构包括C++支持的数据对象、数据类型、类型推断、类型转换以及数据运算等内容。

## 数据对象

数据对象即描述事物（可以是客观的事物，也可以是抽象的事物）的模型。拥有对象名称、内存区域、作用区域、生存周期等特征。在使用数据对象之前需要声明一个数据对象。数据对象的声明即根据数据类型申请一段存储空间创建变量以及可能的初始化。

* 对象名称：即标识符，根据对象的特征拥有各自的命名规则。

* 内存区域：内存区域是数据对象存储数据的内容空间，包含内存地址、存储类型（数据类型）、存储内容、存储方式等属性。

  * 内存地址：即数据对象存储所在的地址。
  * 存储类型：即我们所说的数据类型，是程序访问内存空间的依据。
  * 存储内容：存储内容是内存空间具体存储的数据，必须与存储类型相符合。
  * 存储方式：存储类别共有两大类：动态存储类别与静态存储类别，其中自动存储类别有auto与register，静态存储类别有extern与static。

    动态存储类别是对象在声明时不分配内存仅在使用时分配的存储方式，静态存储类别是在对象声明时就分配的存储方式。
    
    > * auto：自动存储方式。是C++默认的存储方式，一般可以省略描述符。默认情况下，全局变量与局部变量都是采用自动存储方式。
    > * register：寄存器存储方式。只有局部变量和形式参数才可以定义为寄存器变量。并不能保证一定分配在寄存器中。
    > * extern：外部存储方式。表明该变量在程序开始时就建立了外部变量。其实是已在其他文件中已声明。一般全局变量与函数具有外部属性。
    > * static：静态存储方式。是在对象定义时分配内存，程序结束时注销。对静态局部变量，会自动初始化为零值。

* 作用区域：即数据对象可以正常访问的上下文。经常使用的作用域有全局作用域、局部作用域、区块作用域。
  
  > * 全局作用域：在整个项目中所有区域都可以正常访问。一般为全局变量的作用域。
  > * 模块作用域：即命名空间作用域，在整个命名空间内部都可以正常访问。
  > * 文件作用域：仅在该源码文件中可以正常访问。一般为默认的const常量，静态对象。
  > * 局部作用域：仅在函数或类的内部可以正常访问。一般为局部变量的作用域。
  > * 区块作用域：仅在一个区块中可以正常访问。一般在for、while、switch、if中常见。

* 生存周期：数据对象的生存周期即数据对象存在的周期，分别有程序生存期、函数生存期、区块生存期。

  * 程序生存期：对象的生存期是自对象声明时创建到程序结束时销毁。
  * 局部生存期：对象的生存期是自对象生命时创建到函数返回时销毁。
  * 区块生存期：对象的生存期是自对象声明时创建到所在区块末销毁。

* 对象初始化：其中有一些对象的声明必须指定初始值来初始化，初始化的方法有两种直接初始化与赋值初始化。

  * 直接初始化：使用小括号的方式来指定初始化值初始化`int var_int(12);`。
  * 赋值初始化：使用赋值符号来指定初始化值进行初始化`int var_int = 12;`。

### 数据变量

变量是存储内容可以改变的数据对象。数据变量根据其特征可以分为全局变量、局部变量、静态变量、动态变量等。

* 全局变量：是定义在函数或类的外部的数据变量。如果未指定初始值，通常被初始化为零值。

  ```c++
  int global_int;
  ```

  > Note：全局变量的作用域默认为全局作用域。既由extern来修饰。

* 局部变量：是定义在函数内部的数据变量。如果未指定初始值，则不会被初始化。

  ```c++
  void Print(int index) {
    int temp;
  }
  ```

* 静态变量：

#### 变量的应用

* 变量：
* 数组:
* 指针：

### 数据常量

常量即存储内容不可以改变的对象。可以分为字面值常量、编译时常量、运行时常量。字面值常量只能是标准数据类型的值。在C++中，使用`const`或`constexpr`来标识常量。constexpr是在编译时初始化，而const时在运行时初始化。

* 字面值常量：字面值常量常来直接初始化变量、常量、右值引用。

  ```c++
  // int类型的字面值常量。
  017, 15, 0x0F, 15L, 15U, 15UL /** 八进制形式， 十进制形式， 十六进制形式， 长整型形式， 无符号形式， 无符号长整型形式 */
  // 浮点数类型的字面值常量。
  3.14, 3.14F, 314E-2, 314E-2F  /** 双精度形式， 单精度形式， 科学计数双精度形式， 科学计数单精度形式  */
  // 字符类型的字面值常量。
  'a', L'a', "abc"              /** 字符形式， 宽字符形式， 字符串形式 */
  // 布尔类型的字面值常量。
  true, false
  ```

  > Note：使用反斜杠可以连接多行字符串。之后不允许出现注释或空格。

* 编译时常量：这种方式声明常量时，初始值须在编译时就可以确定

  ```c++
  // 字符串类型的编译时常量。
  constexpr string CON_AUTHOR = "Clark Aaron";
  ```

* 运行时常量：在运行时可以声明的常量，必须在声明时指定初始化值。

  ```c++
  // string类型的运行时常量。
  const string STR_AUTHOR = "Clark Aaron";
  ```

  > Note：在默认的const常量中，其作用域一般为文件作用域，如果在声明时指定为extern常量，则作用域为全局变量。



#### 常量的应用

* 指针常量：是指针类型的常量。指针常量的指向地址不能被改变，但指向地址的数据对象如果是变量，则数据内容可以被改变。

  ```c++
  // 声明指针常量的格式。
  <data type>* const <pointer constant name>;
  // 声明指针常量的举例：一个指向int类型变量的指针常量int_pointer。
  int* const int_pointer;
  // 声明指针常量的举例：一个指向int类型常量的指针常量const_int_pointer。
  const int* const const_int_pointer;
  ```

  > Note：指针常量实际在使用时与指针无区别，只是指针的指向地址不能被改变。

* 引用常量：是通过数据对象的引用来声明的常量，保证引用对象只能读取该数据对象，而不能修改数据对象。

  ```c++
  // 声明引用常量的格式。
  const <type>& <varName> = <var>;
  // 声明引用常量的举例：一个int类型的数据int_var的引用常量quote_const。
  int int_var = 10;
  const int&  quote_const = int_var;
  ```

## 数据类型

数据类型是描述数据对象在内存空间的存储方法。C++支持C的数据类型之外扩展自己的数据类型。数据类型的内存空间是由编译器来决定其大小的。在C++中，内置了标准数据类型：int、float、double、char、wchar_t、bool八种数据类型。按照数据类型的特征可以分为以下几类：

### 数值类型

数值类型主要包含整数类型、浮点类型。主要用于计算机中数值的计算。

| 类型 | 说明 | 类型 | 说明 |
|:---:|:--- |:---:|:--- |
| short | 有符号短整型 | unsigned short | 无符号短整型 |
| int | 有符号整型 | unsigned int | 无符号整型 |
| long | 有符号长整型 | unsigned long | 无符号长整型 |
| float | 单精度浮点类型 | double | 双精度浮点类型 |
| long double | 扩展浮点数 |

* `short` or `unsigned short`：short占半个Word。
* `int` or `unsigned int`：int占一个Word。
* `long` or `unsigned long`：long占两个Word。
* `float` or `double`：float一般占1个Word，保证6位有效数字；double占两个Word，保证10位有效数字；long double占三个或四个Word。
* 当赋值超过类型允许的范围的对象后，编译器会将该值对类型取值范围进去取模运算后的值，例如将336赋值到`unsigned char`类型的对象，编译器会对336进行256的取模得到80，然后将80赋值给对象。在C++中将负数赋值为无符号的对象是合法的，但也会进行取模后进行赋值。


### 字符类型

C++除了支持C语言的char类型外，还扩展了string类型的字符串。

| 类型 | 说明 |
|:---:|:--- |
| char | 1个字节的字符 |
| wchar_t | 2个字节的宽字符 |
| char16_t | 2字节的多字节字符 |
| char32_t | 4字节的多字节字符 |
| string | 窄字节的字符串类型 |
| wstring | 宽字节的字符串类型 |

* `char`：占据1B的内存空间，能存储一个字节标识的ASCII编码、ISO-8859编码的所有字符，或者UTF-8编码与Shift-JIS中的单个字符。 
* `wchar_t`：在Windows中编译器中占据2B的内存空间，可以存储UTF-16LE编码所有的字符。
* `char16_t`：占据2B的内存空间，可以存储UTF-16编码的字符。
* `char32_t`：占据4B的内存空间，可以存储UTF-32编码的字符。
* `string`：是C++扩展的字符串类型，需要包含头文件string后才能使用，字符串结尾包含一个结束字符`\0`。
* `wstring`：是C++扩展的字符串类型，

#### 转义字符

转义字符是用于特殊用途的字符。

| 字符 | 八进制表示 | 十六进制表示 | 说明 |
|:---:|:--- |:--- |:--- |
| `\a` | \007 | \x007 | 响铃符 |
| `\b` | | | 退格符 |
| `\f` | | | 进纸符 |
| `\n` | | | 换行符 |
| `\r` | | | 回车符 |
| `\t` | | | 水平制表符 |
| `\v` | | | 垂直制表符 |
| `\?` | | | 疑问号 |
| `\'` | | | 单引号 |
| `\"` | | | 双引号 |
| `\\` | | | 反斜杠 |

#### 格式字符

格式字符是用于格式化字符串数据对象的字符。

| 字符 | 说明 |
|:---:|:--- |
| `%c` | 字符对象 |
| `%d` | 十进制整数对象 |
| `%e` | 数值的科学技术形式，通过e的大写来大写指数符号E |
| `%f` | 浮点数类型 |
| `%g` | 科学技术或浮点数两者最简形式 |
| `%h` | 同l |
| `%i` | 整型 |
| `%l` | 用于输入浮点数 |
| `%o` | 八进制整数 |
| `%s` | 字符串形式 |
| `%u` | 无符号十进制形式 |
| `%x` | 十六进制整型 |

> Note：在%与控制字符之间可以放入标志字符，域宽与精度。标志有+、-、空格、#、0，域宽与精度格式为m.n。

### 布尔类型

* `bool`：占据1B大小的内存空间，只有true与false两个值。在C++中任何数值类型数字可以赋值给布尔类型，其中0为false，非0数字为true。

### 空白类型

空白类型是指void类型。

### 指针类型

指针是只存储数据对象地址的数据类型。在32位的模式下，地址是32wei的，即占据4B大小的内存空间。

#### 指针的声明

指针的声明需要指定其指向内存空间存储的述据类型，同时也提供一种无类型指针`void*`可以存储任何类型的指针，作为函数的参数可以接收任何指针类型，但是在访问该指针指向的存储内容时，需要强制转换具有数据类型的指针。

* 指针的声明：

  ```c++
  <type>* <varName>;
  ```

  > Note：指针在未指定初始值时，使用NULL初始化。

#### 指针的应用

指针在声明时自动使用零值初始化，称为空指针；同时也可以使用`&`来引用已有数据变量的地址，或使用`malloc()`、`new`分配内存空间来初始化指针，分配的内容空间必须使用`free`、`delete`回收；在使用`malloc`时需使用强制类型转换成具有数据类型的指针类型。

* 指针的引用初始化：

  ```c++
  int* intPtr = &<var>;
  ```

* 指针的`malloc`内存分配初始化：

  ```c++
  #include<stdlib.h>
  int* intPtr = (int*)malloc(sizeof(int));
  free(intPtr);
  ```

* 指针的`new`内存分配初始化：

  ```c++
  int* intPtr = new <type>(<value>);
  delete intPtr;
  ```

  > Note：使用type类型的value数据对指针进行初始化和声明。

#### 智能指针

能够自动释放内存的指针，在memory中，包括auto_ptr、shared_ptr、unique_ptr；auto_ptr是独占智能指针，
一个对象只能被一个auto_ptr所指；shared_ptr是共享智能指针，多个指针可以指向同一个对象；unique_ptr是
更安全的auto_ptr。

* 指针指针的定义：

  ```c++
  #include<memory>
  // 定义一个空的智能指针。
  <smartPointer><int> intPtr;
  // 使用已有的智能指针初始化执政指针。
  <smartPointer><int> intPtr(smartPointer);
  // 使用内存分配初始化一个智能指针。
  <smartPointer><int> intPtr(new <type>(<value>));
  ```

  > Note：smartPointer是指auto_ptr、shared_ptr、unique_ptr，其中auto_ptr与shared
  > _ptr可以在同类型的智能指针间赋值，unique_ptr不允许；所有智能指针不能与普通指针互相赋值，但可以通过智能指针的get()
  > 与swap()获取智能指针的地址或交换指针的内容。

#### 常量指针

常量指针是指向常量的指针，又称为底层const。

* 常量指针：

  ```c++
  const int* <ptrName>;
  ```

### 引用类型

引用类型是一种特殊的数据类型。即为数据对象设定别名，并没有自己的内存地址。实际就是对象地址的别名；在C++11中，增加了右值引用。

* 左值引用：左值引用是为存在对象设定别名，使用`&`来设定。

  ```c++
  <type>& <alias> = <object>;
  ```

* 右值引用：右值引用是为临时对象设定别名，使用`&&`来设定，只能绑定到常量或即将销毁的对象上。

  ```c++
  <type>&& <alias> = <object>;
  ```

#### 引用的应用

* 常量引用：常量引用是对常量的引用

### 数组类型

数组是同一数据类型的集合，需要指定数组大小。

#### 数组的声明

* 数组的声明：

  ```c++
  <type>[<array size>] <array name>;
  ```

#### 数组的应用

* 获取数组首元素地址：

  ```c++
  #include<iterator>
  <ptr> = begin(<array>);
  ```

* 获取数组尾元素地址：

  ```c++
  #include<iterator>
  <ptr> = end(<array>);
  ```

### 结构类型

是C++保留C语言的自定义结构，同时也是实现ADT封装的方法，与class类似。

 * `struct`：

#### 结构的定义

* 结构的定义：

  ```c++
  ```

#### 结构的应用

* 结构的应用：

  ```c++
  ```

### 联合类型

#### 联合的定义

#### 联合的应用



### 抽象类型

类是将抽象自客观存在的一类对象的一种自定义的抽象数据类型，是C++面向对象编程的核心，是继承与多态的基础。

#### 类的定义

类的定义有两种方式，直接定义与分离定义；在分离定义中，如果只声明但没有实现类，则称类为不完全类型，只用于定义指针、引用、函数的形参或返回。不完全类型经常出现在类的数据成员的类型为类本身时，这时只能声明为指针或引用。

* 类的直接定义：

  ```c++
  class Human {
    private:
      string name;
    public：
      Human();
      ~Human();
  };
  ```

  > Note：类的定义必须以;结束，是因为在类的定义之后还可以有一个对象定义列表。

* 类的分离定义：

#### 类的数据成员

类的数据成员即描述类的数据特征，一般设定为私有成员；通过接口来管理数据，不支持本身的对象、寄存器、外部、constexpr与decltype；
C++11之后，在类中中可以指定类内初始值。在类中，常量成员、引用成员、类对象成员以及派生类的构造函数对超类构造函数的调用必须采用类内初始值
或者构造方法的初始化列表来进行初始化。一般使用初始化列表初始化数据成员。

* 可变数据成员：可变数据成员不经常使用。可变数据成员可以在常量方法中改变、对象为常量时也可以被改变，使用`mutable`来声明。

  ```c++
  class Human {
    private:
      mutable string name;
    public：
      void Print() const;
  }

  void Human::Print() const {
    cout << this.name;
    this->name = "NULL";
  }
  ```

#### 类的方法成员

类的方法成员即类的行为特征，本质是函数，一般设定为公开成员，作为ADT的外部接口；可以在类内直接实现；也可以在类内声明，类外实现。在方程成员中，
有一个默认参数this指针。

#### 类的静态成员

静态成员是独立于任意该类型对象而存在的，所有实例化对象共享；是实现类间内存共享的机制。静态方法只能访问静态数据成员，使用static修饰。

* 静态数据成员：不能通过构造方法初始化，只能在定义时指定初始值。

  ```C++
  class Human {
    private:
      string name;
      static int COUNT;
      static initCount();
  }

  int Human::COUNT = initCount();     // 使用静态方法initCount()来初始化COUNT。
  ```

  在静态数据成员中，有一种特殊的静态数据成员：静态常量成员`const static int DAY;`

* 静态方法成员：没有this指针，可以直接访问静态数据成员，但不能直接访问非静态数据成员。不能被声明为常量方法于虚拟方法。

  ```c++
  class Human {
    private:
      string name;
      static int COUNT;
    public:
      static int Count();
  }

  int Count() {
    cout<< COUNT;
    return COUNT;
  }
  ```

  > Note：static仅在方法声明时出现，在方法实现时不出现。

#### 类的常量成员

类的常量成员时类所具有的

* 类的常量数据成员：只能在构造方法的初始化列表中初始化。

* 类的常量方法成员：

### 枚举类型

## 类型推断

auto与decltype是C++11引入的类型推断定义符。

* `auto`：默认初始值类型推断（auto使编译器运用表达式结果推断述据类型并使用结果初始化变量。一般忽略表达式的指针常量与引用常量，常量指针会保留下来）。
  
  ```c++
  auto var = 1+2;
  ```

* `decltype`：指定初始值类型推断（只推断类型并不使用结果初始化变量）。

  ```c++
  decltype(<experssion>) var = value;
  decltype((<experssion>)) var = value;   // 引用
  ```

## 数据转换

### 进制转换

### 类型转换

类型转换即将数据对象的数据类型转换为另一种数据类型过程。根据数据类型的精度不同，在将高精度类型转化为低精度数据类型时会发生精度丢失的现象。

#### 隐式转换

隐式转换即自动类型转换，C++在以下四种情况下会隐式的转换述据类型。

* 同一算数中出现了多种不同的述据类型时自动转换：`{char,short,bool}-> int -> float -> double -> long double`。
* 不同数据类型间赋值时自动转换：将等式左边的数据类型转化为右边的述据类型后赋值。
* 在函数调用中，将实参类型转化为形参述据类型。
* 在函数返回值中，将返回表达式转换为返回值类型。

#### 强制转换

使用`(<type>)`或`<type>()`来强制类型转换。

* 在标准C++中,支持四种强制类型转换符static_cast、synamic_cast、const_cast、reinterpret_cast。

    ```c++
    // 将var转化为int类型。
    int i = static_cast <int> (var);
    ```

## 数据运算

### 算数运算符

算数运算符是处理数值运算的操作符。

* `*`：数值间的乘法运算。
* `/`：数值间的除法运算。
* `%`：数值间的取余运算。
* `+`：数值间的加法运算。同时也作为取正数的运算符使用。
* `-`：数值间的减法运算。同时也作为取负数的运算符使用。


### 关系运算符

关系运算符是处理大小关系的运算符，返回一个布尔值。

* `==`：左值等于右值。
* `!=`：左值不等于右值。
* `>`：左值大于右值。
* `<=`左值不大于右值。
* `<`：左值小于右值。
* `>=`：左值不小于右值。

### 逻辑运算符

逻辑运算符是处理布尔运算的操作符，返回一个布尔值。

* `!`：布尔值的非运算。
* `&&`：布尔值间的与运算。
* `||`：布尔值间的或运算。


### 比特运算符

比特运算符是处理二进制位的运算符，返回二进制数据。

* `~`：二进制数据的取反运算。
* `<<`：二进制数据的左移运算，相当于数值上乘以2的运算。
* `>>`：二进制数据的右移运算，相当于数值上除以2的运算。
* `&`：二进制数据间的与运算。
* `^`：二进制数据间的异或运算。
* `|`：二进制数据间的或运算。

### 赋值运算符

赋值运算符是处理对象赋值的操作符。

* `=`：对象间之间赋值运算。
* `+=`：左值与右值相加后在赋值给左值。
* `-=`：左值与右值相减后在赋值给左值。
* `*=`：左值与右值相成后在赋值给左值。
* `/=`：左值与右值相除后在赋值给左值。
* `%=`：左值与右值取余后在赋值给左值。
* `&=`：左值与右值二进制相与后赋值给左值。
* `|=`：左值与右值二进制相或后赋值给左值。
* `^=`：左值与右值二进制异或后赋值给左值。
* `<<=`：左值左移后赋值给左值。
* `>>=`：左值右移后赋值给左值。

### 地址运算符

地址运算符是处理指针的运算符。

* `*`：取指针的指向对象或地址的存储内容。
* `&`：取对象的地址。

### 步进运算符

* `++`：自增运算符，根据操作符位置有先增后增之分。
* `--`：自减运算符，根据操作夫位置有先减后减之分。

### 成员运算符

* `.`：获取类、结构、联合类型对象的成员运算符。
* `->`：获取类、结构、联合类型指针的成员运算符。

### 其他运算符

* 条件运算符：`<condition expression>?:<true code>:<flase code>`分支结构的运算符。
* 内存运算符：`sizeof(<object>)`获取对象的内存大小。
* 逗号运算符：`<object> = <expression_1>,<expression_2>`从左至右依次执行表达式，将最右边结果赋值给左值。
* 输入流运算符：`<istream> >> <object>`输入流读取操作符，将输入流中数据读取到数据对象中。会忽略开始的空白字符，并到遇到空白字符或非数据对象类型时停止读取。
* 输出流运算符：`<ostream> << <object>`输出流写入操作符，将数据对象写入输出数据流中，返回输出流的引用。

  * 格式输出函数：格式输出的函数都在iomanip中。

    * `setprecision(<count>)`：设置有效数字为count位，持续有效。
    * `setw(<count>)`：设置固定宽度为count位，默认右对齐，只对一个输出数据有效。
    * `setiosflags(ios::{right|left})`：设置输出数据的对齐方式,持续有效。
    * `resetiosflags(ios::{right|left})`：取消输出数据的对齐方式。
    