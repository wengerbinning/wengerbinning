# 设计模式

设计模式是最佳的实践,是软件人员在软件开发过程中面临的一般问题的解决方案.是为了重用代码,保证代码的可靠性。


## 创建型模式

这类设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

### 单例模式

Singleton Pattern主要解决一个全局使用的类进行频繁的创建和销毁对象的问题，抱证一个类仅有一个实例，并提供一个访问该实例的全局访问点。


* 解决问题：一个全局使用的类频繁地创建与销毁。
* 设计目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
* 适用场景：当您想控制实例数目，节省系统资源的时候。例如多任务同时操作一个文件。
* 实现原理：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
* 实现方法：构造方法是私有的，并提供一个获取对象的静态方法。

#### 实现方式

* 懒汉式：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

* 饿汉式：它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

* 双检锁：

* 登记式：

* 枚举式：



### 工厂模式

Factory pattern主要解决接口选择的问题。

* 解决问题：主要解决接口选择的问题。
* 设计目的：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
* 适用场景：我们明确地计划不同条件下创建不同实例时。
* 设计原理：让其子类实现工厂接口，返回的也是一个抽象的产品。
* 实现方法：创建过程在其子类执行。

### 原型模式

### 建造者模式

### 抽象工厂模式

## 结构型模式

### 装饰器模式

* 装饰器模式:对于已存在的某些类进行装饰.

## 行为型模式

### 观察者模式

* 观察者模式:定义对象间的一种一对多的依赖关系.


