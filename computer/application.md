# 程序

程序是计算机解决问题的一系列指令集合。一般程序存储在硬盘上，在程序运行时，才会由加载器复制到内存中；当内存中溢出时，会将暂时不需要的数据更新到硬盘中，从而将当前需要的数据加载进来，这样会有实际使用内存大于物理内存的现象，将多出的一部分称为虚拟内存，即虚拟内存等于实际使用内存减去物理内存。为了提高CPU从内存中读取数据，在CPU中增加了缓存来暂时存储CPU经常读取的数据（缓存命中率的问题），寄存器是CPU实际运算数据的存储器，我们常说的CPU位数是指寄存器的位数，例如32位CPU的一个寄存器有32位。

程序可以分为GUI与CUI程序，在Windows中，在GUI程序中，入口函数为WinMain()或者wWinMain()，CUI程序的入口函数为main()或者wmian()。

## 进程

进程是一个程序运行时的实例，由进程的内核对象与地址空间构成。进程的内核对象是OS用来管理进程，也是OS保存进程统计信息的区域；是线程的容器。地址空间包括可执行文件、dll模块的代码和数据、动态内存分配。进程具有惰性，进程的任务是由线程在它的上下文中运行。

## 虚拟地址空间

在所有的OS中，每一个进程都有各自独立的虚拟地址空间。对于32位模式下，进程的虚拟地址空间的大小是4GB；对于64位模式下，进程的虚拟地址空间的大小是16EB。当然虚拟地址空间是虚拟的，为了可以正常的访问，需要将物理内存空间通过页表映射到虚拟内存空间。在虚拟地址空间由用户分区与内核分区构成。这些分区也会根据OS内核不同而具有不同具有不同的大小。在32位模式下，Linux的用户分区为3GB，内核分区为1GB；Windows默认为用户分区2GB，内核分区为2GB，但是通过对BCD（Boot Configuration Data）的修改可以实现3GB用户模式的配置，通过`bcdedit /enum`可以查看BCD信息。但是在3GB用户模式下，系统的内存被限制在64GB，而2GB用户模式下，内存被限制在128GB。

<!-- * 空指针赋值分区：【0x00000000 ~ 0x0000FFFF】这个分区是帮助开发人员捕获对空指针的赋值。当 -->
<!-- cnblogs.com/beixiaobei/p/10507462.html -->
* 用户分区：【0x00010000 ~ 0xBFFFFFFF】（3GB）是进程地址空间的驻地，包含可执行文件、动态链接库、堆、栈
  
  > * 空指针赋值区：[0x00000000 ~ 0x0000FFFF]（64KB）是捕获NULL指针赋值的区域，在使用malloc分配内存时，如果失败则返回NULL，NULL实际地址就位于这一分区，禁止用户访问，这一区域也禁止被开发人员分配。
  > * 代码段：程序代码、字面常量、只读常量存储的位置。
  > * 数据段：已初始化为非零的全局变量与静态局部变量。
  > * BSS段：未初始化或初始化为零值的全集变量与静态局部变量。
  > * 堆段：动态内存分配区域。是链表封装。
  > * 内存映射段：是硬盘内容直接映射到内存的区域，被用于状态动态共享库。
  > * 栈段：局部变量、函数参数、返回地址的区域。是连续的区域。

* 内核分区：【0xC0000000 ~ 0xFFFFFFFF】（1GB）是OS内核代码的驻地，与线程调度、内存管理、文件系统的支持、网络支持以及设备驱动程序有关的代码都载入到该分区。所有进程的虚拟地址空间都映射在同一份物理内存空间，但是禁止被开发人员访问。

在系统创建进程时，可用地址空间中大部分都是闲置（free）或者未被分配的，为了能够使用这部分地址空间，必须调用VirtualAlloc来分配其中的区域，而将分配这一操作称为预定。在预定之后，还需要分配物理内存，映射到预定的地址，将这一过程称为调拨。


## 线程

线程是由线程的内核对象与线程栈构成的。线程的内核对象是用来存放线程统计信息的地方，线程栈是用于维护线程执行时所需要的所有函数参数和局部变量。同一进程内的线程间共享内存空间与内核对象的句柄。

* 线程的内核对象：包含线程的上下文和其他统计信息。

### 超线程

